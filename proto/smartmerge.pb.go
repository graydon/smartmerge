// Code generated by protoc-gen-gogo.
// source: dc-smartmerge.proto
// DO NOT EDIT!

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		dc-smartmerge.proto

	It has these top-level messages:
		State
		Conf
		ConfReply
		NewCur
		NewCurReply
		Read
		ReadReply
		WriteS
		WriteN
		WriteNReply
		LAProposal
		LAReply
		NewState
		NewStateReply
		CV
		Prepare
		Promise
		Propose
		Learn
		Proposal
		Ack
*/
package proto

import (
	fmt "fmt"

	proto1 "github.com/gogo/protobuf/proto"

	_ "github.com/relab/gorums"

	bytes "bytes"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"

	reflect "reflect"
)

import math "math"

import blueprints "github.com/relab/smartmerge/blueprints"

import (
	"encoding/binary"
	"hash/fnv"
	"log"
	"net"
	"sort"
	"sync"
	"time"

	"golang.org/x/net/trace"

	"google.golang.org/grpc/codes"
)

import strings "strings"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type State struct {
	Value     []byte `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
	Timestamp int32  `protobuf:"varint,2,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Writer    uint32 `protobuf:"varint,3,opt,name=Writer,proto3" json:"Writer,omitempty"`
}

func (m *State) Reset()                    { *m = State{} }
func (*State) ProtoMessage()               {}
func (*State) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{0} }

// This message hold the hash value of the current configuration,
// and the configuration used for this quorum call
type Conf struct {
	This uint32 `protobuf:"varint,1,opt,name=This,proto3" json:"This,omitempty"`
	Cur  uint32 `protobuf:"varint,2,opt,name=Cur,proto3" json:"Cur,omitempty"`
}

func (m *Conf) Reset()                    { *m = Conf{} }
func (*Conf) ProtoMessage()               {}
func (*Conf) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{1} }

type ConfReply struct {
	Cur   *blueprints.Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Abort bool                    `protobuf:"varint,2,opt,name=Abort,proto3" json:"Abort,omitempty"`
	Next  []*blueprints.Blueprint `protobuf:"bytes,3,rep,name=Next" json:"Next,omitempty"`
}

func (m *ConfReply) Reset()                    { *m = ConfReply{} }
func (*ConfReply) ProtoMessage()               {}
func (*ConfReply) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{2} }

func (m *ConfReply) GetCur() *blueprints.Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *ConfReply) GetNext() []*blueprints.Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type NewCur struct {
	Cur  *blueprints.Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	CurC uint32                `protobuf:"varint,2,opt,name=CurC,proto3" json:"CurC,omitempty"`
}

func (m *NewCur) Reset()                    { *m = NewCur{} }
func (*NewCur) ProtoMessage()               {}
func (*NewCur) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{3} }

func (m *NewCur) GetCur() *blueprints.Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

type NewCurReply struct {
	New bool `protobuf:"varint,1,opt,name=New,proto3" json:"New,omitempty"`
}

func (m *NewCurReply) Reset()                    { *m = NewCurReply{} }
func (*NewCurReply) ProtoMessage()               {}
func (*NewCurReply) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{4} }

type Read struct {
	Conf *Conf `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
}

func (m *Read) Reset()                    { *m = Read{} }
func (*Read) ProtoMessage()               {}
func (*Read) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{5} }

func (m *Read) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type ReadReply struct {
	State *State     `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Cur   *ConfReply `protobuf:"bytes,2,opt,name=Cur" json:"Cur,omitempty"`
}

func (m *ReadReply) Reset()                    { *m = ReadReply{} }
func (*ReadReply) ProtoMessage()               {}
func (*ReadReply) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{6} }

func (m *ReadReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ReadReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

type WriteS struct {
	State *State `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Conf  *Conf  `protobuf:"bytes,2,opt,name=Conf" json:"Conf,omitempty"`
}

func (m *WriteS) Reset()                    { *m = WriteS{} }
func (*WriteS) ProtoMessage()               {}
func (*WriteS) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{7} }

func (m *WriteS) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WriteS) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

type WriteN struct {
	CurC uint32                `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Next *blueprints.Blueprint `protobuf:"bytes,2,opt,name=Next" json:"Next,omitempty"`
}

func (m *WriteN) Reset()                    { *m = WriteN{} }
func (*WriteN) ProtoMessage()               {}
func (*WriteN) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{8} }

func (m *WriteN) GetNext() *blueprints.Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type WriteNReply struct {
	Cur     *ConfReply            `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	State   *State                `protobuf:"bytes,2,opt,name=State" json:"State,omitempty"`
	LAState *blueprints.Blueprint `protobuf:"bytes,3,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *WriteNReply) Reset()                    { *m = WriteNReply{} }
func (*WriteNReply) ProtoMessage()               {}
func (*WriteNReply) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{9} }

func (m *WriteNReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *WriteNReply) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *WriteNReply) GetLAState() *blueprints.Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type LAProposal struct {
	Conf *Conf                 `protobuf:"bytes,1,opt,name=Conf" json:"Conf,omitempty"`
	Prop *blueprints.Blueprint `protobuf:"bytes,2,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *LAProposal) Reset()                    { *m = LAProposal{} }
func (*LAProposal) ProtoMessage()               {}
func (*LAProposal) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{10} }

func (m *LAProposal) GetConf() *Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *LAProposal) GetProp() *blueprints.Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type LAReply struct {
	Cur     *ConfReply            `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	LAState *blueprints.Blueprint `protobuf:"bytes,2,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *LAReply) Reset()                    { *m = LAReply{} }
func (*LAReply) ProtoMessage()               {}
func (*LAReply) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{11} }

func (m *LAReply) GetCur() *ConfReply {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *LAReply) GetLAState() *blueprints.Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type NewState struct {
	CurC    uint32                `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	State   *State                `protobuf:"bytes,2,opt,name=State" json:"State,omitempty"`
	LAState *blueprints.Blueprint `protobuf:"bytes,3,opt,name=LAState" json:"LAState,omitempty"`
}

func (m *NewState) Reset()                    { *m = NewState{} }
func (*NewState) ProtoMessage()               {}
func (*NewState) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{12} }

func (m *NewState) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *NewState) GetLAState() *blueprints.Blueprint {
	if m != nil {
		return m.LAState
	}
	return nil
}

type NewStateReply struct {
	Cur  *blueprints.Blueprint   `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Next []*blueprints.Blueprint `protobuf:"bytes,2,rep,name=Next" json:"Next,omitempty"`
}

func (m *NewStateReply) Reset()                    { *m = NewStateReply{} }
func (*NewStateReply) ProtoMessage()               {}
func (*NewStateReply) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{13} }

func (m *NewStateReply) GetCur() *blueprints.Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *NewStateReply) GetNext() []*blueprints.Blueprint {
	if m != nil {
		return m.Next
	}
	return nil
}

type CV struct {
	Rnd uint32                `protobuf:"varint,1,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	Val *blueprints.Blueprint `protobuf:"bytes,2,opt,name=Val" json:"Val,omitempty"`
}

func (m *CV) Reset()                    { *m = CV{} }
func (*CV) ProtoMessage()               {}
func (*CV) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{14} }

func (m *CV) GetVal() *blueprints.Blueprint {
	if m != nil {
		return m.Val
	}
	return nil
}

type Prepare struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Rnd  uint32 `protobuf:"varint,2,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
}

func (m *Prepare) Reset()                    { *m = Prepare{} }
func (*Prepare) ProtoMessage()               {}
func (*Prepare) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{15} }

type Promise struct {
	Cur *blueprints.Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Rnd uint32                `protobuf:"varint,2,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	Val *CV                   `protobuf:"bytes,3,opt,name=Val" json:"Val,omitempty"`
	Dec *blueprints.Blueprint `protobuf:"bytes,4,opt,name=Dec" json:"Dec,omitempty"`
}

func (m *Promise) Reset()                    { *m = Promise{} }
func (*Promise) ProtoMessage()               {}
func (*Promise) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{16} }

func (m *Promise) GetCur() *blueprints.Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *Promise) GetVal() *CV {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Promise) GetDec() *blueprints.Blueprint {
	if m != nil {
		return m.Dec
	}
	return nil
}

type Propose struct {
	CurC uint32 `protobuf:"varint,1,opt,name=CurC,proto3" json:"CurC,omitempty"`
	Val  *CV    `protobuf:"bytes,2,opt,name=Val" json:"Val,omitempty"`
}

func (m *Propose) Reset()                    { *m = Propose{} }
func (*Propose) ProtoMessage()               {}
func (*Propose) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{17} }

func (m *Propose) GetVal() *CV {
	if m != nil {
		return m.Val
	}
	return nil
}

type Learn struct {
	Cur     *blueprints.Blueprint `protobuf:"bytes,1,opt,name=Cur" json:"Cur,omitempty"`
	Dec     *blueprints.Blueprint `protobuf:"bytes,2,opt,name=Dec" json:"Dec,omitempty"`
	Learned bool                  `protobuf:"varint,3,opt,name=Learned,proto3" json:"Learned,omitempty"`
}

func (m *Learn) Reset()                    { *m = Learn{} }
func (*Learn) ProtoMessage()               {}
func (*Learn) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{18} }

func (m *Learn) GetCur() *blueprints.Blueprint {
	if m != nil {
		return m.Cur
	}
	return nil
}

func (m *Learn) GetDec() *blueprints.Blueprint {
	if m != nil {
		return m.Dec
	}
	return nil
}

type Proposal struct {
	Prop *blueprints.Blueprint `protobuf:"bytes,1,opt,name=Prop" json:"Prop,omitempty"`
}

func (m *Proposal) Reset()                    { *m = Proposal{} }
func (*Proposal) ProtoMessage()               {}
func (*Proposal) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{19} }

func (m *Proposal) GetProp() *blueprints.Blueprint {
	if m != nil {
		return m.Prop
	}
	return nil
}

type Ack struct {
}

func (m *Ack) Reset()                    { *m = Ack{} }
func (*Ack) ProtoMessage()               {}
func (*Ack) Descriptor() ([]byte, []int) { return fileDescriptorDcSmartMerge, []int{20} }

func init() {
	proto1.RegisterType((*State)(nil), "proto.State")
	proto1.RegisterType((*Conf)(nil), "proto.Conf")
	proto1.RegisterType((*ConfReply)(nil), "proto.ConfReply")
	proto1.RegisterType((*NewCur)(nil), "proto.NewCur")
	proto1.RegisterType((*NewCurReply)(nil), "proto.NewCurReply")
	proto1.RegisterType((*Read)(nil), "proto.Read")
	proto1.RegisterType((*ReadReply)(nil), "proto.ReadReply")
	proto1.RegisterType((*WriteS)(nil), "proto.WriteS")
	proto1.RegisterType((*WriteN)(nil), "proto.WriteN")
	proto1.RegisterType((*WriteNReply)(nil), "proto.WriteNReply")
	proto1.RegisterType((*LAProposal)(nil), "proto.LAProposal")
	proto1.RegisterType((*LAReply)(nil), "proto.LAReply")
	proto1.RegisterType((*NewState)(nil), "proto.NewState")
	proto1.RegisterType((*NewStateReply)(nil), "proto.NewStateReply")
	proto1.RegisterType((*CV)(nil), "proto.CV")
	proto1.RegisterType((*Prepare)(nil), "proto.Prepare")
	proto1.RegisterType((*Promise)(nil), "proto.Promise")
	proto1.RegisterType((*Propose)(nil), "proto.Propose")
	proto1.RegisterType((*Learn)(nil), "proto.Learn")
	proto1.RegisterType((*Proposal)(nil), "proto.Proposal")
	proto1.RegisterType((*Ack)(nil), "proto.Ack")
}
func (this *State) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*State)
	if !ok {
		that2, ok := that.(State)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *State")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *State but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *State but is not nil && this == nil")
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if this.Writer != that1.Writer {
		return fmt.Errorf("Writer this(%v) Not Equal that(%v)", this.Writer, that1.Writer)
	}
	return nil
}
func (this *State) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*State)
	if !ok {
		that2, ok := that.(State)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Writer != that1.Writer {
		return false
	}
	return true
}
func (this *Conf) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Conf)
	if !ok {
		that2, ok := that.(Conf)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Conf")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Conf but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Conf but is not nil && this == nil")
	}
	if this.This != that1.This {
		return fmt.Errorf("This this(%v) Not Equal that(%v)", this.This, that1.This)
	}
	if this.Cur != that1.Cur {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	return nil
}
func (this *Conf) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Conf)
	if !ok {
		that2, ok := that.(Conf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.This != that1.This {
		return false
	}
	if this.Cur != that1.Cur {
		return false
	}
	return true
}
func (this *ConfReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ConfReply)
	if !ok {
		that2, ok := that.(ConfReply)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ConfReply")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ConfReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ConfReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if this.Abort != that1.Abort {
		return fmt.Errorf("Abort this(%v) Not Equal that(%v)", this.Abort, that1.Abort)
	}
	if len(this.Next) != len(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", len(this.Next), len(that1.Next))
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return fmt.Errorf("Next this[%v](%v) Not Equal that[%v](%v)", i, this.Next[i], i, that1.Next[i])
		}
	}
	return nil
}
func (this *ConfReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ConfReply)
	if !ok {
		that2, ok := that.(ConfReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if this.Abort != that1.Abort {
		return false
	}
	if len(this.Next) != len(that1.Next) {
		return false
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return false
		}
	}
	return true
}
func (this *NewCur) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewCur)
	if !ok {
		that2, ok := that.(NewCur)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *NewCur")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewCur but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewCur but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	return nil
}
func (this *NewCur) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewCur)
	if !ok {
		that2, ok := that.(NewCur)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	return true
}
func (this *NewCurReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewCurReply)
	if !ok {
		that2, ok := that.(NewCurReply)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *NewCurReply")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewCurReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewCurReply but is not nil && this == nil")
	}
	if this.New != that1.New {
		return fmt.Errorf("New this(%v) Not Equal that(%v)", this.New, that1.New)
	}
	return nil
}
func (this *NewCurReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewCurReply)
	if !ok {
		that2, ok := that.(NewCurReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.New != that1.New {
		return false
	}
	return true
}
func (this *Read) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Read)
	if !ok {
		that2, ok := that.(Read)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Read")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Read but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Read but is not nil && this == nil")
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	return nil
}
func (this *Read) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Read)
	if !ok {
		that2, ok := that.(Read)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	return true
}
func (this *ReadReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ReadReply)
	if !ok {
		that2, ok := that.(ReadReply)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ReadReply")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ReadReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ReadReply but is not nil && this == nil")
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	return nil
}
func (this *ReadReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ReadReply)
	if !ok {
		that2, ok := that.(ReadReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	return true
}
func (this *WriteS) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WriteS)
	if !ok {
		that2, ok := that.(WriteS)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *WriteS")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *WriteS but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *WriteS but is not nil && this == nil")
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	return nil
}
func (this *WriteS) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WriteS)
	if !ok {
		that2, ok := that.(WriteS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	return true
}
func (this *WriteN) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WriteN)
	if !ok {
		that2, ok := that.(WriteN)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *WriteN")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *WriteN but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *WriteN but is not nil && this == nil")
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	if !this.Next.Equal(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", this.Next, that1.Next)
	}
	return nil
}
func (this *WriteN) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WriteN)
	if !ok {
		that2, ok := that.(WriteN)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	if !this.Next.Equal(that1.Next) {
		return false
	}
	return true
}
func (this *WriteNReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WriteNReply)
	if !ok {
		that2, ok := that.(WriteNReply)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *WriteNReply")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *WriteNReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *WriteNReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.LAState.Equal(that1.LAState) {
		return fmt.Errorf("LAState this(%v) Not Equal that(%v)", this.LAState, that1.LAState)
	}
	return nil
}
func (this *WriteNReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WriteNReply)
	if !ok {
		that2, ok := that.(WriteNReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.LAState.Equal(that1.LAState) {
		return false
	}
	return true
}
func (this *LAProposal) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LAProposal)
	if !ok {
		that2, ok := that.(LAProposal)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *LAProposal")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LAProposal but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LAProposal but is not nil && this == nil")
	}
	if !this.Conf.Equal(that1.Conf) {
		return fmt.Errorf("Conf this(%v) Not Equal that(%v)", this.Conf, that1.Conf)
	}
	if !this.Prop.Equal(that1.Prop) {
		return fmt.Errorf("Prop this(%v) Not Equal that(%v)", this.Prop, that1.Prop)
	}
	return nil
}
func (this *LAProposal) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LAProposal)
	if !ok {
		that2, ok := that.(LAProposal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Conf.Equal(that1.Conf) {
		return false
	}
	if !this.Prop.Equal(that1.Prop) {
		return false
	}
	return true
}
func (this *LAReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LAReply)
	if !ok {
		that2, ok := that.(LAReply)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *LAReply")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LAReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LAReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.LAState.Equal(that1.LAState) {
		return fmt.Errorf("LAState this(%v) Not Equal that(%v)", this.LAState, that1.LAState)
	}
	return nil
}
func (this *LAReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LAReply)
	if !ok {
		that2, ok := that.(LAReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.LAState.Equal(that1.LAState) {
		return false
	}
	return true
}
func (this *NewState) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewState)
	if !ok {
		that2, ok := that.(NewState)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *NewState")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewState but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewState but is not nil && this == nil")
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	if !this.State.Equal(that1.State) {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if !this.LAState.Equal(that1.LAState) {
		return fmt.Errorf("LAState this(%v) Not Equal that(%v)", this.LAState, that1.LAState)
	}
	return nil
}
func (this *NewState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewState)
	if !ok {
		that2, ok := that.(NewState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.LAState.Equal(that1.LAState) {
		return false
	}
	return true
}
func (this *NewStateReply) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewStateReply)
	if !ok {
		that2, ok := that.(NewStateReply)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *NewStateReply")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewStateReply but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewStateReply but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if len(this.Next) != len(that1.Next) {
		return fmt.Errorf("Next this(%v) Not Equal that(%v)", len(this.Next), len(that1.Next))
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return fmt.Errorf("Next this[%v](%v) Not Equal that[%v](%v)", i, this.Next[i], i, that1.Next[i])
		}
	}
	return nil
}
func (this *NewStateReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewStateReply)
	if !ok {
		that2, ok := that.(NewStateReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if len(this.Next) != len(that1.Next) {
		return false
	}
	for i := range this.Next {
		if !this.Next[i].Equal(that1.Next[i]) {
			return false
		}
	}
	return true
}
func (this *CV) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CV)
	if !ok {
		that2, ok := that.(CV)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CV")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CV but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CV but is not nil && this == nil")
	}
	if this.Rnd != that1.Rnd {
		return fmt.Errorf("Rnd this(%v) Not Equal that(%v)", this.Rnd, that1.Rnd)
	}
	if !this.Val.Equal(that1.Val) {
		return fmt.Errorf("Val this(%v) Not Equal that(%v)", this.Val, that1.Val)
	}
	return nil
}
func (this *CV) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CV)
	if !ok {
		that2, ok := that.(CV)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	return true
}
func (this *Prepare) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Prepare)
	if !ok {
		that2, ok := that.(Prepare)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Prepare")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Prepare but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Prepare but is not nil && this == nil")
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	if this.Rnd != that1.Rnd {
		return fmt.Errorf("Rnd this(%v) Not Equal that(%v)", this.Rnd, that1.Rnd)
	}
	return nil
}
func (this *Prepare) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Prepare)
	if !ok {
		that2, ok := that.(Prepare)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	return true
}
func (this *Promise) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Promise)
	if !ok {
		that2, ok := that.(Promise)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Promise")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Promise but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Promise but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if this.Rnd != that1.Rnd {
		return fmt.Errorf("Rnd this(%v) Not Equal that(%v)", this.Rnd, that1.Rnd)
	}
	if !this.Val.Equal(that1.Val) {
		return fmt.Errorf("Val this(%v) Not Equal that(%v)", this.Val, that1.Val)
	}
	if !this.Dec.Equal(that1.Dec) {
		return fmt.Errorf("Dec this(%v) Not Equal that(%v)", this.Dec, that1.Dec)
	}
	return nil
}
func (this *Promise) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Promise)
	if !ok {
		that2, ok := that.(Promise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	if !this.Dec.Equal(that1.Dec) {
		return false
	}
	return true
}
func (this *Propose) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Propose)
	if !ok {
		that2, ok := that.(Propose)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Propose")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Propose but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Propose but is not nil && this == nil")
	}
	if this.CurC != that1.CurC {
		return fmt.Errorf("CurC this(%v) Not Equal that(%v)", this.CurC, that1.CurC)
	}
	if !this.Val.Equal(that1.Val) {
		return fmt.Errorf("Val this(%v) Not Equal that(%v)", this.Val, that1.Val)
	}
	return nil
}
func (this *Propose) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Propose)
	if !ok {
		that2, ok := that.(Propose)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CurC != that1.CurC {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	return true
}
func (this *Learn) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Learn)
	if !ok {
		that2, ok := that.(Learn)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Learn")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Learn but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Learn but is not nil && this == nil")
	}
	if !this.Cur.Equal(that1.Cur) {
		return fmt.Errorf("Cur this(%v) Not Equal that(%v)", this.Cur, that1.Cur)
	}
	if !this.Dec.Equal(that1.Dec) {
		return fmt.Errorf("Dec this(%v) Not Equal that(%v)", this.Dec, that1.Dec)
	}
	if this.Learned != that1.Learned {
		return fmt.Errorf("Learned this(%v) Not Equal that(%v)", this.Learned, that1.Learned)
	}
	return nil
}
func (this *Learn) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Learn)
	if !ok {
		that2, ok := that.(Learn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Cur.Equal(that1.Cur) {
		return false
	}
	if !this.Dec.Equal(that1.Dec) {
		return false
	}
	if this.Learned != that1.Learned {
		return false
	}
	return true
}
func (this *Proposal) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Proposal)
	if !ok {
		that2, ok := that.(Proposal)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Proposal")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Proposal but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Proposal but is not nil && this == nil")
	}
	if !this.Prop.Equal(that1.Prop) {
		return fmt.Errorf("Prop this(%v) Not Equal that(%v)", this.Prop, that1.Prop)
	}
	return nil
}
func (this *Proposal) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Proposal)
	if !ok {
		that2, ok := that.(Proposal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Prop.Equal(that1.Prop) {
		return false
	}
	return true
}
func (this *Ack) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Ack)
	if !ok {
		that2, ok := that.(Ack)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Ack")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Ack but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Ack but is not nil && this == nil")
	}
	return nil
}
func (this *Ack) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Ack)
	if !ok {
		that2, ok := that.(Ack)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}

//  Reference Gorums specific imports to suppress errors if they are not otherwise used.
var _ = codes.OK

/* 'gorums' plugin for protoc-gen-go - generated from: config_qc_tmpl */

// AcceptReply encapsulates the reply from a Accept quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type AcceptReply struct {
	NodeIDs []uint32
	*Learn
}

func (r AcceptReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.Learn)
}

// Accept invokes a Accept quorum call on configuration c
// and returns the result as a AcceptReply.
func (c *Configuration) Accept(ctx context.Context, args *Propose) (*AcceptReply, error) {
	return c.mgr.accept(ctx, c, args)
}

// GetPromiseReply encapsulates the reply from a GetPromise quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type GetPromiseReply struct {
	NodeIDs []uint32
	*Promise
}

func (r GetPromiseReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.Promise)
}

// GetPromise invokes a GetPromise quorum call on configuration c
// and returns the result as a GetPromiseReply.
func (c *Configuration) GetPromise(ctx context.Context, args *Prepare) (*GetPromiseReply, error) {
	return c.mgr.getPromise(ctx, c, args)
}

// LAPropReply encapsulates the reply from a LAProp quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type LAPropReply struct {
	NodeIDs []uint32
	*LAReply
}

func (r LAPropReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.LAReply)
}

// LAProp invokes a LAProp quorum call on configuration c
// and returns the result as a LAPropReply.
func (c *Configuration) LAProp(ctx context.Context, args *LAProposal) (*LAPropReply, error) {
	return c.mgr.lAProp(ctx, c, args)
}

// ReadReply_ encapsulates the reply from a Read quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type ReadReply_ struct {
	NodeIDs []uint32
	*ReadReply
}

func (r ReadReply_) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.ReadReply)
}

// Read invokes a Read quorum call on configuration c
// and returns the result as a ReadReply_.
func (c *Configuration) Read(ctx context.Context, args *Conf) (*ReadReply_, error) {
	return c.mgr.read(ctx, c, args)
}

// SetCurReply encapsulates the reply from a SetCur quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type SetCurReply struct {
	NodeIDs []uint32
	*NewCurReply
}

func (r SetCurReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.NewCurReply)
}

// SetCur invokes a SetCur quorum call on configuration c
// and returns the result as a SetCurReply.
func (c *Configuration) SetCur(ctx context.Context, args *NewCur) (*SetCurReply, error) {
	return c.mgr.setCur(ctx, c, args)
}

// SetStateReply encapsulates the reply from a SetState quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type SetStateReply struct {
	NodeIDs []uint32
	*NewStateReply
}

func (r SetStateReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.NewStateReply)
}

// SetState invokes a SetState quorum call on configuration c
// and returns the result as a SetStateReply.
func (c *Configuration) SetState(ctx context.Context, args *NewState) (*SetStateReply, error) {
	return c.mgr.setState(ctx, c, args)
}

// WriteReply encapsulates the reply from a Write quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type WriteReply struct {
	NodeIDs []uint32
	*ConfReply
}

func (r WriteReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.ConfReply)
}

// Write invokes a Write quorum call on configuration c
// and returns the result as a WriteReply.
func (c *Configuration) Write(ctx context.Context, args *WriteS) (*WriteReply, error) {
	return c.mgr.write(ctx, c, args)
}

// WriteNextReply encapsulates the reply from a WriteNext quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type WriteNextReply struct {
	NodeIDs []uint32
	*WriteNReply
}

func (r WriteNextReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.WriteNReply)
}

// WriteNext invokes a WriteNext quorum call on configuration c
// and returns the result as a WriteNextReply.
func (c *Configuration) WriteNext(ctx context.Context, args *WriteN) (*WriteNextReply, error) {
	return c.mgr.writeNext(ctx, c, args)
}

/* 'gorums' plugin for protoc-gen-go - generated from: mgr_qc_tmpl */

type acceptReply struct {
	nid   uint32
	reply *Learn
	err   error
}

func (m *Manager) accept(ctx context.Context, c *Configuration, args *Propose) (r *AcceptReply, err error) {
	var ti traceInfo
	if m.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "Accept")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   r.NodeIDs,
				reply: r.Learn,
				err:   err,
			}, false)
			if err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan acceptReply, c.n)

	if m.opts.trace {
		ti.tr.LazyLog(&payload{sent: true, msg: args}, false)
	}

	for _, n := range c.nodes {
		go callGRPCAccept(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*Learn, 0, c.n)
		reply       = &AcceptReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if m.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply.Learn, quorum = c.qspec.AcceptQF(replyValues); quorum {
				return reply, nil
			}
		case <-ctx.Done():
			return reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCAccept(ctx context.Context, node *Node, args *Propose, replyChan chan<- acceptReply) {
	reply := new(Learn)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/proto.SMandConsRegister/Accept",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- acceptReply{node.id, reply, err}
}

type getPromiseReply struct {
	nid   uint32
	reply *Promise
	err   error
}

func (m *Manager) getPromise(ctx context.Context, c *Configuration, args *Prepare) (r *GetPromiseReply, err error) {
	var ti traceInfo
	if m.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "GetPromise")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   r.NodeIDs,
				reply: r.Promise,
				err:   err,
			}, false)
			if err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan getPromiseReply, c.n)

	if m.opts.trace {
		ti.tr.LazyLog(&payload{sent: true, msg: args}, false)
	}

	for _, n := range c.nodes {
		go callGRPCGetPromise(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*Promise, 0, c.n)
		reply       = &GetPromiseReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if m.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply.Promise, quorum = c.qspec.GetPromiseQF(replyValues); quorum {
				return reply, nil
			}
		case <-ctx.Done():
			return reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCGetPromise(ctx context.Context, node *Node, args *Prepare, replyChan chan<- getPromiseReply) {
	reply := new(Promise)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/proto.SMandConsRegister/GetPromise",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- getPromiseReply{node.id, reply, err}
}

type lAPropReply struct {
	nid   uint32
	reply *LAReply
	err   error
}

func (m *Manager) lAProp(ctx context.Context, c *Configuration, args *LAProposal) (r *LAPropReply, err error) {
	var ti traceInfo
	if m.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "LAProp")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   r.NodeIDs,
				reply: r.LAReply,
				err:   err,
			}, false)
			if err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan lAPropReply, c.n)

	if m.opts.trace {
		ti.tr.LazyLog(&payload{sent: true, msg: args}, false)
	}

	for _, n := range c.nodes {
		go callGRPCLAProp(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*LAReply, 0, c.n)
		reply       = &LAPropReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if m.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply.LAReply, quorum = c.qspec.LAPropQF(replyValues); quorum {
				return reply, nil
			}
		case <-ctx.Done():
			return reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCLAProp(ctx context.Context, node *Node, args *LAProposal, replyChan chan<- lAPropReply) {
	reply := new(LAReply)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/proto.SMandConsRegister/LAProp",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- lAPropReply{node.id, reply, err}
}

type readReply struct {
	nid   uint32
	reply *ReadReply
	err   error
}

func (m *Manager) read(ctx context.Context, c *Configuration, args *Conf) (r *ReadReply_, err error) {
	var ti traceInfo
	if m.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "Read")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   r.NodeIDs,
				reply: r.ReadReply,
				err:   err,
			}, false)
			if err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan readReply, c.n)

	if m.opts.trace {
		ti.tr.LazyLog(&payload{sent: true, msg: args}, false)
	}

	for _, n := range c.nodes {
		go callGRPCRead(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*ReadReply, 0, c.n)
		reply       = &ReadReply_{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if m.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply.ReadReply, quorum = c.qspec.ReadQF(replyValues); quorum {
				return reply, nil
			}
		case <-ctx.Done():
			return reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCRead(ctx context.Context, node *Node, args *Conf, replyChan chan<- readReply) {
	reply := new(ReadReply)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/proto.SMandConsRegister/Read",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- readReply{node.id, reply, err}
}

type setCurReply struct {
	nid   uint32
	reply *NewCurReply
	err   error
}

func (m *Manager) setCur(ctx context.Context, c *Configuration, args *NewCur) (r *SetCurReply, err error) {
	var ti traceInfo
	if m.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "SetCur")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   r.NodeIDs,
				reply: r.NewCurReply,
				err:   err,
			}, false)
			if err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan setCurReply, c.n)

	if m.opts.trace {
		ti.tr.LazyLog(&payload{sent: true, msg: args}, false)
	}

	for _, n := range c.nodes {
		go callGRPCSetCur(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*NewCurReply, 0, c.n)
		reply       = &SetCurReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if m.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply.NewCurReply, quorum = c.qspec.SetCurQF(replyValues); quorum {
				return reply, nil
			}
		case <-ctx.Done():
			return reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCSetCur(ctx context.Context, node *Node, args *NewCur, replyChan chan<- setCurReply) {
	reply := new(NewCurReply)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/proto.SMandConsRegister/SetCur",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- setCurReply{node.id, reply, err}
}

type setStateReply struct {
	nid   uint32
	reply *NewStateReply
	err   error
}

func (m *Manager) setState(ctx context.Context, c *Configuration, args *NewState) (r *SetStateReply, err error) {
	var ti traceInfo
	if m.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "SetState")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   r.NodeIDs,
				reply: r.NewStateReply,
				err:   err,
			}, false)
			if err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan setStateReply, c.n)

	if m.opts.trace {
		ti.tr.LazyLog(&payload{sent: true, msg: args}, false)
	}

	for _, n := range c.nodes {
		go callGRPCSetState(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*NewStateReply, 0, c.n)
		reply       = &SetStateReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if m.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply.NewStateReply, quorum = c.qspec.SetStateQF(replyValues); quorum {
				return reply, nil
			}
		case <-ctx.Done():
			return reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCSetState(ctx context.Context, node *Node, args *NewState, replyChan chan<- setStateReply) {
	reply := new(NewStateReply)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/proto.SMandConsRegister/SetState",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- setStateReply{node.id, reply, err}
}

type writeReply struct {
	nid   uint32
	reply *ConfReply
	err   error
}

func (m *Manager) write(ctx context.Context, c *Configuration, args *WriteS) (r *WriteReply, err error) {
	var ti traceInfo
	if m.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "Write")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   r.NodeIDs,
				reply: r.ConfReply,
				err:   err,
			}, false)
			if err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan writeReply, c.n)

	if m.opts.trace {
		ti.tr.LazyLog(&payload{sent: true, msg: args}, false)
	}

	for _, n := range c.nodes {
		go callGRPCWrite(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*ConfReply, 0, c.n)
		reply       = &WriteReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if m.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply.ConfReply, quorum = c.qspec.WriteQF(replyValues); quorum {
				return reply, nil
			}
		case <-ctx.Done():
			return reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCWrite(ctx context.Context, node *Node, args *WriteS, replyChan chan<- writeReply) {
	reply := new(ConfReply)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/proto.SMandConsRegister/Write",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- writeReply{node.id, reply, err}
}

type writeNextReply struct {
	nid   uint32
	reply *WriteNReply
	err   error
}

func (m *Manager) writeNext(ctx context.Context, c *Configuration, args *WriteN) (r *WriteNextReply, err error) {
	var ti traceInfo
	if m.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "WriteNext")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   r.NodeIDs,
				reply: r.WriteNReply,
				err:   err,
			}, false)
			if err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan writeNextReply, c.n)

	if m.opts.trace {
		ti.tr.LazyLog(&payload{sent: true, msg: args}, false)
	}

	for _, n := range c.nodes {
		go callGRPCWriteNext(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*WriteNReply, 0, c.n)
		reply       = &WriteNextReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if m.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply.WriteNReply, quorum = c.qspec.WriteNextQF(replyValues); quorum {
				return reply, nil
			}
		case <-ctx.Done():
			return reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCWriteNext(ctx context.Context, node *Node, args *WriteN, replyChan chan<- writeNextReply) {
	reply := new(WriteNReply)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/proto.SMandConsRegister/WriteNext",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- writeNextReply{node.id, reply, err}
}

/* 'gorums' plugin for protoc-gen-go - generated from: node_tmpl */

// Node encapsulates the state of a node on which a remote procedure call
// can be made.
type Node struct {
	// Only assigned at creation.
	id   uint32
	self bool
	addr string
	conn *grpc.ClientConn

	SMandConsRegisterClient SMandConsRegisterClient

	sync.Mutex
	lastErr error
	latency time.Duration
}

func (n *Node) connect(opts ...grpc.DialOption) error {
	var err error
	n.conn, err = grpc.Dial(n.addr, opts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}

	n.SMandConsRegisterClient = NewSMandConsRegisterClient(n.conn)

	return nil
}

func (n *Node) close() error {
	// TODO: Log error, mainly care about the connection error below.
	// We should log this error, but we currently don't have access to the
	// logger in the manager.

	if err := n.conn.Close(); err != nil {
		return fmt.Errorf("conn close error: %v", err)
	}
	return nil
}

/* 'gorums' plugin for protoc-gen-go - generated from: qspec_tmpl */

// QuorumSpec is the interface that wraps every quorum function.
type QuorumSpec interface {
	// AcceptQF is the quorum function for the Accept
	// quorum call method.
	AcceptQF(replies []*Learn) (*Learn, bool)

	// GetPromiseQF is the quorum function for the GetPromise
	// quorum call method.
	GetPromiseQF(replies []*Promise) (*Promise, bool)

	// LAPropQF is the quorum function for the LAProp
	// quorum call method.
	LAPropQF(replies []*LAReply) (*LAReply, bool)

	// ReadQF is the quorum function for the Read
	// quorum call method.
	ReadQF(replies []*ReadReply) (*ReadReply, bool)

	// SetCurQF is the quorum function for the SetCur
	// quorum call method.
	SetCurQF(replies []*NewCurReply) (*NewCurReply, bool)

	// SetStateQF is the quorum function for the SetState
	// quorum call method.
	SetStateQF(replies []*NewStateReply) (*NewStateReply, bool)

	// WriteQF is the quorum function for the Write
	// quorum call method.
	WriteQF(replies []*ConfReply) (*ConfReply, bool)

	// WriteNextQF is the quorum function for the WriteNext
	// quorum call method.
	WriteNextQF(replies []*WriteNReply) (*WriteNReply, bool)
}

/* Static resources */

/* config.go */

// A Configuration represents a static set of nodes on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id    uint32
	nodes []*Node
	n     int
	mgr   *Manager
	qspec QuorumSpec
}

// ID reports the identifier for the configuration.
func (c *Configuration) ID() uint32 {
	return c.id
}

// NodeIDs returns a slice containing the local ids of all the nodes in the
// configuration. IDs are returned in the same order as they were provided in
// the creation of the Configuration.
func (c *Configuration) NodeIDs() []uint32 {
	ids := make([]uint32, len(c.nodes))
	for i, node := range c.nodes {
		ids[i] = node.ID()
	}
	return ids
}

// Nodes returns a slice of each available node. IDs are returned in the same
// order as they were provided in the creation of the Configuration.
func (c *Configuration) Nodes() []*Node {
	return c.nodes
}

// Size returns the number of nodes in the configuration.
func (c *Configuration) Size() int {
	return c.n
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d", c.id)
}

func (c *Configuration) tstring() string {
	return fmt.Sprintf("config-%d", c.id)
}

// Equal returns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.id == b.id }

// NewTestConfiguration returns a new configuration with quorum size q and
// node size n. No other fields are set. Configurations returned from this
// constructor should only be used when testing quorum functions.
func NewTestConfiguration(q, n int) *Configuration {
	return &Configuration{
		nodes: make([]*Node, n),
	}
}

/* errors.go */

// A NodeNotFoundError reports that a specified node could not be found.
type NodeNotFoundError uint32

func (e NodeNotFoundError) Error() string {
	return fmt.Sprintf("node not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// ManagerCreationError returns an error reporting that a Manager could not be
// created due to err.
func ManagerCreationError(err error) error {
	return fmt.Errorf("could not create manager: %s", err.Error())
}

// A QuorumCallError is used to report that a quorum call failed.
type QuorumCallError struct {
	Reason               string
	ErrCount, ReplyCount int
}

func (e QuorumCallError) Error() string {
	return fmt.Sprintf(
		"quorum call error: %s (errors: %d, replies: %d)",
		e.Reason, e.ErrCount, e.ReplyCount,
	)
}

/* level.go */

// LevelNotSet is the zero value level used to indicate that no level (and
// thereby no reply) has been set for a correctable quorum call.
const LevelNotSet = -1

/* mgr.go */

// Manager manages a pool of node configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	sync.Mutex
	nodes    []*Node
	lookup   map[uint32]*Node
	configs  map[uint32]*Configuration
	eventLog trace.EventLog

	closeOnce sync.Once
	logger    *log.Logger
	opts      managerOptions
}

// NewManager attempts to connect to the given set of node addresses and if
// successful returns a new Manager containing connections to those nodes.
func NewManager(nodeAddrs []string, opts ...ManagerOption) (*Manager, error) {
	if len(nodeAddrs) == 0 {
		return nil, fmt.Errorf("could not create manager: no nodes provided")
	}

	m := &Manager{
		lookup:  make(map[uint32]*Node),
		configs: make(map[uint32]*Configuration),
	}

	for _, opt := range opts {
		opt(&m.opts)
	}

	for _, naddr := range nodeAddrs {
		node, err2 := m.createNode(naddr)
		if err2 != nil {
			return nil, ManagerCreationError(err2)
		}
		m.lookup[node.id] = node
		m.nodes = append(m.nodes, node)
	}

	if m.opts.trace {
		title := strings.Join(nodeAddrs, ",")
		m.eventLog = trace.NewEventLog("gorums.Manager", title)
	}

	err := m.connectAll()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	if m.eventLog != nil {
		m.eventLog.Printf("ready")
	}

	return m, nil
}

func (m *Manager) createNode(addr string) (*Node, error) {
	m.Lock()
	defer m.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("create node %s error: %v", addr, err)
	}

	h := fnv.New32a()
	_, _ = h.Write([]byte(tcpAddr.String()))
	id := h.Sum32()

	if _, found := m.lookup[id]; found {
		return nil, fmt.Errorf("create node %s error: node already exists", addr)
	}

	node := &Node{
		id:      id,
		addr:    tcpAddr.String(),
		latency: -1 * time.Second,
	}

	return node, nil
}

func (m *Manager) connectAll() error {
	if m.opts.noConnect {
		return nil
	}

	if m.eventLog != nil {
		m.eventLog.Printf("connecting")
	}

	for _, node := range m.nodes {
		err := node.connect(m.opts.grpcDialOpts...)
		if err != nil {
			if m.eventLog != nil {
				m.eventLog.Errorf("connect failed, error connecting to node %s, error: %v", node.addr, err)
			}
			return fmt.Errorf("connect node %s error: %v", node.addr, err)
		}
	}
	return nil
}

func (m *Manager) closeNodeConns() {
	for _, node := range m.nodes {
		err := node.close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("node %d: error closing: %v", node.id, err)
		}
	}
}

// Close closes all node connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		if m.eventLog != nil {
			m.eventLog.Printf("closing")
		}
		m.closeNodeConns()
	})
}

// NodeIDs returns the identifier of each available node. IDs are returned in
// the same order as they were provided in the creation of the Manager.
func (m *Manager) NodeIDs() []uint32 {
	m.Lock()
	defer m.Unlock()
	ids := make([]uint32, 0, len(m.nodes))
	for _, node := range m.nodes {
		ids = append(ids, node.ID())
	}
	return ids
}

// Node returns the node with the given identifier if present.
func (m *Manager) Node(id uint32) (node *Node, found bool) {
	m.Lock()
	defer m.Unlock()
	node, found = m.lookup[id]
	return node, found
}

// Nodes returns a slice of each available node. IDs are returned in the same
// order as they were provided in the creation of the Manager.
func (m *Manager) Nodes() []*Node {
	m.Lock()
	defer m.Unlock()
	return m.nodes
}

// ConfigurationIDs returns the identifier of each available
// configuration.
func (m *Manager) ConfigurationIDs() []uint32 {
	m.Lock()
	defer m.Unlock()
	ids := make([]uint32, 0, len(m.configs))
	for id := range m.configs {
		ids = append(ids, id)
	}
	return ids
}

// Configuration returns the configuration with the given global
// identifier if present.
func (m *Manager) Configuration(id uint32) (config *Configuration, found bool) {
	m.Lock()
	defer m.Unlock()
	config, found = m.configs[id]
	return config, found
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.Lock()
	defer m.Unlock()
	configs := make([]*Configuration, 0, len(m.configs))
	for _, conf := range m.configs {
		configs = append(configs, conf)
	}
	return configs
}

// Size returns the number of nodes and configurations in the Manager.
func (m *Manager) Size() (nodes, configs int) {
	m.Lock()
	defer m.Unlock()
	return len(m.nodes), len(m.configs)
}

// AddNode attempts to dial to the provide node address. The node is
// added to the Manager's pool of nodes if a connection was established.
func (m *Manager) AddNode(addr string) error {
	panic("not implemented")
}

// NewConfiguration returns a new configuration given quorum specification and
// a timeout.
func (m *Manager) NewConfiguration(ids []uint32, qspec QuorumSpec) (*Configuration, error) {
	m.Lock()
	defer m.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one node")
	}

	var cnodes []*Node
	for _, nid := range ids {
		node, found := m.lookup[nid]
		if !found {
			return nil, NodeNotFoundError(nid)
		}
		cnodes = append(cnodes, node)
	}

	// Node ids are sorted ensure a globally consistent configuration id.
	sort.Sort(idSlice(ids))

	h := fnv.New32a()
	for _, id := range ids {
		binary.Write(h, binary.LittleEndian, id)
	}
	cid := h.Sum32()

	conf, found := m.configs[cid]
	if found {
		return conf, nil
	}

	c := &Configuration{
		id:    cid,
		nodes: cnodes,
		n:     len(cnodes),
		mgr:   m,
		qspec: qspec,
	}
	m.configs[cid] = c

	return c, nil
}

type idSlice []uint32

func (p idSlice) Len() int           { return len(p) }
func (p idSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p idSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

/* node_func.go */

// ID returns the ID of m.
func (n *Node) ID() uint32 {
	return n.id
}

// Address returns network address of m.
func (n *Node) Address() string {
	return n.addr
}

func (n *Node) String() string {
	n.Lock()
	defer n.Unlock()
	return fmt.Sprintf(
		"node %d | addr: %s | latency: %v",
		n.id, n.addr, n.latency,
	)
}

func (n *Node) setLastErr(err error) {
	n.Lock()
	defer n.Unlock()
	n.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this node.
func (n *Node) LastErr() error {
	n.Lock()
	defer n.Unlock()
	return n.lastErr
}

func (n *Node) setLatency(lat time.Duration) {
	n.Lock()
	defer n.Unlock()
	n.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this node.
func (n *Node) Latency() time.Duration {
	n.Lock()
	defer n.Unlock()
	return n.latency
}

type lessFunc func(n1, n2 *Node) bool

// MultiSorter implements the Sort interface, sorting the nodes within.
type MultiSorter struct {
	nodes []*Node
	less  []lessFunc
}

// Sort sorts the argument slice according to the less functions passed to
// OrderedBy.
func (ms *MultiSorter) Sort(nodes []*Node) {
	ms.nodes = nodes
	sort.Sort(ms)
}

// OrderedBy returns a Sorter that sorts using the less functions, in order.
// Call its Sort method to sort the data.
func OrderedBy(less ...lessFunc) *MultiSorter {
	return &MultiSorter{
		less: less,
	}
}

// Len is part of sort.Interface.
func (ms *MultiSorter) Len() int {
	return len(ms.nodes)
}

// Swap is part of sort.Interface.
func (ms *MultiSorter) Swap(i, j int) {
	ms.nodes[i], ms.nodes[j] = ms.nodes[j], ms.nodes[i]
}

// Less is part of sort.Interface. It is implemented by looping along the
// less functions until it finds a comparison that is either Less or
// !Less. Note that it can call the less functions twice per call. We
// could change the functions to return -1, 0, 1 and reduce the
// number of calls for greater efficiency: an exercise for the reader.
func (ms *MultiSorter) Less(i, j int) bool {
	p, q := ms.nodes[i], ms.nodes[j]
	// Try all but the last comparison.
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			// p < q, so we have a decision.
			return true
		case less(q, p):
			// p > q, so we have a decision.
			return false
		}
		// p == q; try the next comparison.
	}
	// All comparisons to here said "equal", so just return whatever
	// the final comparison reports.
	return ms.less[k](p, q)
}

// ID sorts nodes by their identifier in increasing order.
var ID = func(n1, n2 *Node) bool {
	return n1.id < n2.id
}

// Latency sorts nodes by latency in increasing order. Latencies less then
// zero (sentinel value) are considered greater than any positive latency.
var Latency = func(n1, n2 *Node) bool {
	if n1.latency < 0 {
		return false
	}
	return n1.latency < n2.latency

}

// Error sorts nodes by their LastErr() status in increasing order. A
// node with LastErr() != nil is larger than a node with LastErr() == nil.
var Error = func(n1, n2 *Node) bool {
	if n1.lastErr != nil && n2.lastErr == nil {
		return false
	}
	return true
}

/* opts.go */

type managerOptions struct {
	grpcDialOpts []grpc.DialOption
	logger       *log.Logger
	noConnect    bool
	trace        bool
}

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each node in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its nodes. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// WithTracing controls whether to trace qourum calls for this Manager instance
// using the golang.org/x/net/trace package. Tracing is currently only supported
// for regular quorum calls.
func WithTracing() ManagerOption {
	return func(o *managerOptions) {
		o.trace = true
	}
}

/* trace.go */

type traceInfo struct {
	tr        trace.Trace
	firstLine firstLine
}

type firstLine struct {
	deadline time.Duration
	cid      uint32
}

func (f *firstLine) String() string {
	var line bytes.Buffer
	io.WriteString(&line, "QC: to config")
	fmt.Fprintf(&line, "%v deadline:", f.cid)
	if f.deadline != 0 {
		fmt.Fprint(&line, f.deadline)
	} else {
		io.WriteString(&line, "none")
	}
	return line.String()
}

type payload struct {
	sent bool
	id   uint32
	msg  interface{}
}

func (p payload) String() string {
	if p.sent {
		return fmt.Sprintf("sent: %v", p.msg)
	}
	return fmt.Sprintf("recv from %d: %v", p.id, p.msg)
}

type qcresult struct {
	ids   []uint32
	reply interface{}
	err   error
}

func (q qcresult) String() string {
	var out bytes.Buffer
	io.WriteString(&out, "recv QC reply: ")
	fmt.Fprintf(&out, "ids: %v, ", q.ids)
	fmt.Fprintf(&out, "reply: %v ", q.reply)
	if q.err != nil {
		fmt.Fprintf(&out, ", error: %v", q.err)
	}
	return out.String()
}

/* util.go */

func appendIfNotPresent(set []uint32, x uint32) []uint32 {
	for _, y := range set {
		if y == x {
			return set
		}
	}
	return append(set, x)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SMandConsRegister service

type SMandConsRegisterClient interface {
	// Read a register value
	Read(ctx context.Context, in *Conf, opts ...grpc.CallOption) (*ReadReply, error)
	// Write a value to the register
	Write(ctx context.Context, in *WriteS, opts ...grpc.CallOption) (*ConfReply, error)
	// Inform the servers about a new proposed configuration/blueprint
	WriteNext(ctx context.Context, in *WriteN, opts ...grpc.CallOption) (*WriteNReply, error)
	// Inform the servers that a new configuration has been installed
	SetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error)
	// Propose a value to lattice agreement
	// Only used in smartmerge algorithm
	LAProp(ctx context.Context, in *LAProposal, opts ...grpc.CallOption) (*LAReply, error)
	// Set register and lattice agreement state in new configuration
	SetState(ctx context.Context, in *NewState, opts ...grpc.CallOption) (*NewStateReply, error)
	// Consensus: Paxos first phase
	// Only used in the consensus based algorithm (RAMBO)
	GetPromise(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Promise, error)
	// Consensus: Paxos second phase
	// Only used in the consensus based algorithm (RAMBO)
	Accept(ctx context.Context, in *Propose, opts ...grpc.CallOption) (*Learn, error)
	// Fwd is used to forward a reconfiguration-proposal to a leader.
	// Only used in the consensus based algorithm (RAMBO)
	Fwd(ctx context.Context, in *Proposal, opts ...grpc.CallOption) (*Ack, error)
}

type sMandConsRegisterClient struct {
	cc *grpc.ClientConn
}

func NewSMandConsRegisterClient(cc *grpc.ClientConn) SMandConsRegisterClient {
	return &sMandConsRegisterClient{cc}
}

func (c *sMandConsRegisterClient) Read(ctx context.Context, in *Conf, opts ...grpc.CallOption) (*ReadReply, error) {
	out := new(ReadReply)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMandConsRegisterClient) Write(ctx context.Context, in *WriteS, opts ...grpc.CallOption) (*ConfReply, error) {
	out := new(ConfReply)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMandConsRegisterClient) WriteNext(ctx context.Context, in *WriteN, opts ...grpc.CallOption) (*WriteNReply, error) {
	out := new(WriteNReply)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/WriteNext", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMandConsRegisterClient) SetCur(ctx context.Context, in *NewCur, opts ...grpc.CallOption) (*NewCurReply, error) {
	out := new(NewCurReply)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/SetCur", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMandConsRegisterClient) LAProp(ctx context.Context, in *LAProposal, opts ...grpc.CallOption) (*LAReply, error) {
	out := new(LAReply)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/LAProp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMandConsRegisterClient) SetState(ctx context.Context, in *NewState, opts ...grpc.CallOption) (*NewStateReply, error) {
	out := new(NewStateReply)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/SetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMandConsRegisterClient) GetPromise(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Promise, error) {
	out := new(Promise)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/GetPromise", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMandConsRegisterClient) Accept(ctx context.Context, in *Propose, opts ...grpc.CallOption) (*Learn, error) {
	out := new(Learn)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/Accept", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMandConsRegisterClient) Fwd(ctx context.Context, in *Proposal, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/proto.SMandConsRegister/Fwd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SMandConsRegister service

type SMandConsRegisterServer interface {
	// Read a register value
	Read(context.Context, *Conf) (*ReadReply, error)
	// Write a value to the register
	Write(context.Context, *WriteS) (*ConfReply, error)
	// Inform the servers about a new proposed configuration/blueprint
	WriteNext(context.Context, *WriteN) (*WriteNReply, error)
	// Inform the servers that a new configuration has been installed
	SetCur(context.Context, *NewCur) (*NewCurReply, error)
	// Propose a value to lattice agreement
	// Only used in smartmerge algorithm
	LAProp(context.Context, *LAProposal) (*LAReply, error)
	// Set register and lattice agreement state in new configuration
	SetState(context.Context, *NewState) (*NewStateReply, error)
	// Consensus: Paxos first phase
	// Only used in the consensus based algorithm (RAMBO)
	GetPromise(context.Context, *Prepare) (*Promise, error)
	// Consensus: Paxos second phase
	// Only used in the consensus based algorithm (RAMBO)
	Accept(context.Context, *Propose) (*Learn, error)
	// Fwd is used to forward a reconfiguration-proposal to a leader.
	// Only used in the consensus based algorithm (RAMBO)
	Fwd(context.Context, *Proposal) (*Ack, error)
}

func RegisterSMandConsRegisterServer(s *grpc.Server, srv SMandConsRegisterServer) {
	s.RegisterService(&_SMandConsRegister_serviceDesc, srv)
}

func _SMandConsRegister_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Conf)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).Read(ctx, req.(*Conf))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMandConsRegister_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteS)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).Write(ctx, req.(*WriteS))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMandConsRegister_WriteNext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteN)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).WriteNext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/WriteNext",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).WriteNext(ctx, req.(*WriteN))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMandConsRegister_SetCur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewCur)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).SetCur(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/SetCur",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).SetCur(ctx, req.(*NewCur))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMandConsRegister_LAProp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LAProposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).LAProp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/LAProp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).LAProp(ctx, req.(*LAProposal))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMandConsRegister_SetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).SetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/SetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).SetState(ctx, req.(*NewState))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMandConsRegister_GetPromise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Prepare)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).GetPromise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/GetPromise",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).GetPromise(ctx, req.(*Prepare))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMandConsRegister_Accept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Propose)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).Accept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/Accept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).Accept(ctx, req.(*Propose))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMandConsRegister_Fwd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Proposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMandConsRegisterServer).Fwd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SMandConsRegister/Fwd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMandConsRegisterServer).Fwd(ctx, req.(*Proposal))
	}
	return interceptor(ctx, in, info, handler)
}

var _SMandConsRegister_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.SMandConsRegister",
	HandlerType: (*SMandConsRegisterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _SMandConsRegister_Read_Handler,
		},
		{
			MethodName: "Write",
			Handler:    _SMandConsRegister_Write_Handler,
		},
		{
			MethodName: "WriteNext",
			Handler:    _SMandConsRegister_WriteNext_Handler,
		},
		{
			MethodName: "SetCur",
			Handler:    _SMandConsRegister_SetCur_Handler,
		},
		{
			MethodName: "LAProp",
			Handler:    _SMandConsRegister_LAProp_Handler,
		},
		{
			MethodName: "SetState",
			Handler:    _SMandConsRegister_SetState_Handler,
		},
		{
			MethodName: "GetPromise",
			Handler:    _SMandConsRegister_GetPromise_Handler,
		},
		{
			MethodName: "Accept",
			Handler:    _SMandConsRegister_Accept_Handler,
		},
		{
			MethodName: "Fwd",
			Handler:    _SMandConsRegister_Fwd_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dc-smartmerge.proto",
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Timestamp))
	}
	if m.Writer != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Writer))
	}
	return i, nil
}

func (m *Conf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Conf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.This != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.This))
	}
	if m.Cur != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur))
	}
	return i, nil
}

func (m *ConfReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur.Size()))
		n1, err := m.Cur.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Abort {
		dAtA[i] = 0x10
		i++
		if m.Abort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDcSmartMerge(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NewCur) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewCur) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur.Size()))
		n2, err := m.Cur.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CurC != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.CurC))
	}
	return i, nil
}

func (m *NewCurReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewCurReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.New {
		dAtA[i] = 0x8
		i++
		if m.New {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Read) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Read) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Conf.Size()))
		n3, err := m.Conf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ReadReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.State.Size()))
		n4, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Cur != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur.Size()))
		n5, err := m.Cur.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *WriteS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.State.Size()))
		n6, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Conf != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Conf.Size()))
		n7, err := m.Conf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *WriteN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteN) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.CurC))
	}
	if m.Next != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Next.Size()))
		n8, err := m.Next.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *WriteNReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteNReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur.Size()))
		n9, err := m.Cur.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.State.Size()))
		n10, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.LAState != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.LAState.Size()))
		n11, err := m.LAState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *LAProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LAProposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Conf.Size()))
		n12, err := m.Conf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Prop != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Prop.Size()))
		n13, err := m.Prop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *LAReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LAReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur.Size()))
		n14, err := m.Cur.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.LAState != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.LAState.Size()))
		n15, err := m.LAState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *NewState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.CurC))
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.State.Size()))
		n16, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.LAState != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.LAState.Size()))
		n17, err := m.LAState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *NewStateReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewStateReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur.Size()))
		n18, err := m.Cur.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.Next) > 0 {
		for _, msg := range m.Next {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDcSmartMerge(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CV) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rnd != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Rnd))
	}
	if m.Val != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Val.Size()))
		n19, err := m.Val.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *Prepare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prepare) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.CurC))
	}
	if m.Rnd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Rnd))
	}
	return i, nil
}

func (m *Promise) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Promise) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur.Size()))
		n20, err := m.Cur.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Rnd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Rnd))
	}
	if m.Val != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Val.Size()))
		n21, err := m.Val.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Dec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Dec.Size()))
		n22, err := m.Dec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *Propose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Propose) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurC != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.CurC))
	}
	if m.Val != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Val.Size()))
		n23, err := m.Val.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *Learn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Learn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Cur.Size()))
		n24, err := m.Cur.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Dec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Dec.Size()))
		n25, err := m.Dec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Learned {
		dAtA[i] = 0x18
		i++
		if m.Learned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Prop != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDcSmartMerge(dAtA, i, uint64(m.Prop.Size()))
		n26, err := m.Prop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *Ack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ack) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64DcSmartMerge(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32DcSmartMerge(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDcSmartMerge(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *State) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Timestamp))
	}
	if m.Writer != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Writer))
	}
	return n
}

func (m *Conf) Size() (n int) {
	var l int
	_ = l
	if m.This != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.This))
	}
	if m.Cur != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Cur))
	}
	return n
}

func (m *ConfReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Abort {
		n += 2
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *NewCur) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	return n
}

func (m *NewCurReply) Size() (n int) {
	var l int
	_ = l
	if m.New {
		n += 2
	}
	return n
}

func (m *Read) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *ReadReply) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *WriteS) Size() (n int) {
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *WriteN) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *WriteNReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *LAProposal) Size() (n int) {
	var l int
	_ = l
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *LAReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *NewState) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.LAState != nil {
		l = m.LAState.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *NewStateReply) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if len(m.Next) > 0 {
		for _, e := range m.Next {
			l = e.Size()
			n += 1 + l + sovDcSmartMerge(uint64(l))
		}
	}
	return n
}

func (m *CV) Size() (n int) {
	var l int
	_ = l
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Prepare) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	return n
}

func (m *Promise) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Rnd != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.Rnd))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Dec != nil {
		l = m.Dec.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Propose) Size() (n int) {
	var l int
	_ = l
	if m.CurC != 0 {
		n += 1 + sovDcSmartMerge(uint64(m.CurC))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Learn) Size() (n int) {
	var l int
	_ = l
	if m.Cur != nil {
		l = m.Cur.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Dec != nil {
		l = m.Dec.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	if m.Learned {
		n += 2
	}
	return n
}

func (m *Proposal) Size() (n int) {
	var l int
	_ = l
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovDcSmartMerge(uint64(l))
	}
	return n
}

func (m *Ack) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovDcSmartMerge(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDcSmartMerge(x uint64) (n int) {
	return sovDcSmartMerge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *State) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&State{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Writer:` + fmt.Sprintf("%v", this.Writer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Conf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Conf{`,
		`This:` + fmt.Sprintf("%v", this.This) + `,`,
		`Cur:` + fmt.Sprintf("%v", this.Cur) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfReply{`,
		`Cur:` + strings.Replace(fmt.Sprintf("%v", this.Cur), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`Abort:` + fmt.Sprintf("%v", this.Abort) + `,`,
		`Next:` + strings.Replace(fmt.Sprintf("%v", this.Next), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NewCur) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NewCur{`,
		`Cur:` + strings.Replace(fmt.Sprintf("%v", this.Cur), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`CurC:` + fmt.Sprintf("%v", this.CurC) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NewCurReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NewCurReply{`,
		`New:` + fmt.Sprintf("%v", this.New) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Read) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Read{`,
		`Conf:` + strings.Replace(fmt.Sprintf("%v", this.Conf), "Conf", "Conf", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadReply{`,
		`State:` + strings.Replace(fmt.Sprintf("%v", this.State), "State", "State", 1) + `,`,
		`Cur:` + strings.Replace(fmt.Sprintf("%v", this.Cur), "ConfReply", "ConfReply", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteS{`,
		`State:` + strings.Replace(fmt.Sprintf("%v", this.State), "State", "State", 1) + `,`,
		`Conf:` + strings.Replace(fmt.Sprintf("%v", this.Conf), "Conf", "Conf", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteN) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteN{`,
		`CurC:` + fmt.Sprintf("%v", this.CurC) + `,`,
		`Next:` + strings.Replace(fmt.Sprintf("%v", this.Next), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteNReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteNReply{`,
		`Cur:` + strings.Replace(fmt.Sprintf("%v", this.Cur), "ConfReply", "ConfReply", 1) + `,`,
		`State:` + strings.Replace(fmt.Sprintf("%v", this.State), "State", "State", 1) + `,`,
		`LAState:` + strings.Replace(fmt.Sprintf("%v", this.LAState), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LAProposal) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LAProposal{`,
		`Conf:` + strings.Replace(fmt.Sprintf("%v", this.Conf), "Conf", "Conf", 1) + `,`,
		`Prop:` + strings.Replace(fmt.Sprintf("%v", this.Prop), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LAReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LAReply{`,
		`Cur:` + strings.Replace(fmt.Sprintf("%v", this.Cur), "ConfReply", "ConfReply", 1) + `,`,
		`LAState:` + strings.Replace(fmt.Sprintf("%v", this.LAState), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NewState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NewState{`,
		`CurC:` + fmt.Sprintf("%v", this.CurC) + `,`,
		`State:` + strings.Replace(fmt.Sprintf("%v", this.State), "State", "State", 1) + `,`,
		`LAState:` + strings.Replace(fmt.Sprintf("%v", this.LAState), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NewStateReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NewStateReply{`,
		`Cur:` + strings.Replace(fmt.Sprintf("%v", this.Cur), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`Next:` + strings.Replace(fmt.Sprintf("%v", this.Next), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CV) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CV{`,
		`Rnd:` + fmt.Sprintf("%v", this.Rnd) + `,`,
		`Val:` + strings.Replace(fmt.Sprintf("%v", this.Val), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Prepare) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Prepare{`,
		`CurC:` + fmt.Sprintf("%v", this.CurC) + `,`,
		`Rnd:` + fmt.Sprintf("%v", this.Rnd) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Promise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Promise{`,
		`Cur:` + strings.Replace(fmt.Sprintf("%v", this.Cur), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`Rnd:` + fmt.Sprintf("%v", this.Rnd) + `,`,
		`Val:` + strings.Replace(fmt.Sprintf("%v", this.Val), "CV", "CV", 1) + `,`,
		`Dec:` + strings.Replace(fmt.Sprintf("%v", this.Dec), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Propose) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Propose{`,
		`CurC:` + fmt.Sprintf("%v", this.CurC) + `,`,
		`Val:` + strings.Replace(fmt.Sprintf("%v", this.Val), "CV", "CV", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Learn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Learn{`,
		`Cur:` + strings.Replace(fmt.Sprintf("%v", this.Cur), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`Dec:` + strings.Replace(fmt.Sprintf("%v", this.Dec), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`Learned:` + fmt.Sprintf("%v", this.Learned) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Proposal) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Proposal{`,
		`Prop:` + strings.Replace(fmt.Sprintf("%v", this.Prop), "Blueprint", "blueprints.Blueprint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ack) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ack{`,
		`}`,
	}, "")
	return s
}
func valueToStringDcSmartMerge(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writer", wireType)
			}
			m.Writer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Writer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Conf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Conf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Conf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field This", wireType)
			}
			m.This = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.This |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			m.Cur = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cur |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &blueprints.Blueprint{}
			}
			if err := m.Cur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Abort = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &blueprints.Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewCur) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewCur: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewCur: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &blueprints.Blueprint{}
			}
			if err := m.Cur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewCurReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewCurReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewCurReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.New = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Read) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Read: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Read: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &blueprints.Blueprint{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteNReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteNReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteNReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &blueprints.Blueprint{}
			}
			if err := m.LAState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LAProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LAProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LAProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &blueprints.Blueprint{}
			}
			if err := m.Prop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LAReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LAReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LAReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &ConfReply{}
			}
			if err := m.Cur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &blueprints.Blueprint{}
			}
			if err := m.LAState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &State{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LAState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LAState == nil {
				m.LAState = &blueprints.Blueprint{}
			}
			if err := m.LAState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewStateReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewStateReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewStateReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &blueprints.Blueprint{}
			}
			if err := m.Cur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Next = append(m.Next, &blueprints.Blueprint{})
			if err := m.Next[len(m.Next)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &blueprints.Blueprint{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Promise) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Promise: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Promise: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &blueprints.Blueprint{}
			}
			if err := m.Cur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &CV{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dec == nil {
				m.Dec = &blueprints.Blueprint{}
			}
			if err := m.Dec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Propose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Propose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Propose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurC", wireType)
			}
			m.CurC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurC |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &CV{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Learn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Learn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Learn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cur == nil {
				m.Cur = &blueprints.Blueprint{}
			}
			if err := m.Cur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dec == nil {
				m.Dec = &blueprints.Blueprint{}
			}
			if err := m.Dec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learned = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prop == nil {
				m.Prop = &blueprints.Blueprint{}
			}
			if err := m.Prop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDcSmartMerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDcSmartMerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDcSmartMerge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDcSmartMerge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDcSmartMerge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDcSmartMerge
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDcSmartMerge
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDcSmartMerge(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDcSmartMerge = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDcSmartMerge   = fmt.Errorf("proto: integer overflow")
)

func init() { proto1.RegisterFile("dc-smartmerge.proto", fileDescriptorDcSmartMerge) }

var fileDescriptorDcSmartMerge = []byte{
	// 764 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x6e, 0xd3, 0x4a,
	0x18, 0x8d, 0xe3, 0x24, 0x4d, 0xbe, 0x24, 0xed, 0xed, 0xdc, 0x7b, 0xab, 0x60, 0x54, 0x2b, 0x0c,
	0x15, 0xaa, 0x44, 0x49, 0x44, 0x00, 0x55, 0xc0, 0x86, 0x34, 0x88, 0x6e, 0xd2, 0xa8, 0x4a, 0xaa,
	0xc0, 0x06, 0x09, 0xc7, 0x19, 0xd2, 0xa8, 0x49, 0x6c, 0xc6, 0x63, 0x52, 0x76, 0x7d, 0x04, 0x1e,
	0x83, 0x17, 0xe0, 0x1d, 0xd8, 0x20, 0x75, 0xc9, 0xb2, 0x35, 0x1b, 0x96, 0x3c, 0x02, 0xf2, 0xcc,
	0xf8, 0xa7, 0x0d, 0x58, 0x59, 0xb0, 0xb2, 0x3d, 0x3e, 0xe7, 0xcc, 0x39, 0xdf, 0x7c, 0xdf, 0xc0,
	0xbf, 0x43, 0xf3, 0x9e, 0x33, 0x35, 0x28, 0x3b, 0x20, 0x74, 0x44, 0x6a, 0x36, 0xb5, 0x98, 0x85,
	0xb2, 0xfc, 0xa1, 0x6d, 0x8d, 0xc6, 0xec, 0xd8, 0x1d, 0xd4, 0x4c, 0x6b, 0x5a, 0xa7, 0x64, 0x62,
	0x0c, 0xea, 0x23, 0x8b, 0xba, 0x53, 0x47, 0x3e, 0x04, 0x58, 0xdb, 0x5d, 0x40, 0x45, 0x7a, 0xf5,
	0xc1, 0xc4, 0x25, 0x36, 0x1d, 0xcf, 0x98, 0x13, 0x7b, 0x15, 0x44, 0xfc, 0x18, 0xb2, 0x3d, 0x66,
	0x30, 0x82, 0xca, 0x90, 0xed, 0x1b, 0x13, 0x97, 0x54, 0x94, 0xaa, 0xb2, 0x5d, 0x42, 0xeb, 0x50,
	0x38, 0x1a, 0x4f, 0x89, 0xc3, 0x8c, 0xa9, 0x5d, 0x49, 0x57, 0x95, 0xed, 0x2c, 0x5a, 0x85, 0xdc,
	0x4b, 0x3a, 0x66, 0x84, 0x56, 0xd4, 0xaa, 0xb2, 0x5d, 0xc6, 0xb7, 0x20, 0xd3, 0xb2, 0x66, 0x6f,
	0x51, 0x09, 0x32, 0x47, 0xc7, 0x63, 0x87, 0x13, 0xcb, 0xa8, 0x08, 0x6a, 0xcb, 0xa5, 0x9c, 0x52,
	0xc6, 0x26, 0x14, 0x7c, 0x48, 0x97, 0xd8, 0x93, 0x0f, 0x08, 0x8b, 0x3f, 0x3e, 0xac, 0xd8, 0xf8,
	0xbf, 0x16, 0xb3, 0xb2, 0x17, 0xbc, 0xfa, 0x2e, 0x9a, 0x03, 0x8b, 0x32, 0xce, 0xcf, 0xa3, 0xdb,
	0x90, 0xe9, 0x90, 0x53, 0x56, 0x51, 0xab, 0xea, 0x1f, 0x39, 0xf8, 0x09, 0xe4, 0x3a, 0x64, 0xde,
	0x72, 0xe9, 0x52, 0x3b, 0x94, 0x20, 0xd3, 0x72, 0x69, 0x4b, 0x1a, 0xd4, 0xa0, 0x28, 0xb8, 0xc2,
	0x62, 0x11, 0xd4, 0x0e, 0x99, 0x73, 0x81, 0xbc, 0x9f, 0xaf, 0x4b, 0x8c, 0x21, 0xba, 0x21, 0x72,
	0x4a, 0xd9, 0xa2, 0x28, 0x5c, 0xcd, 0x5f, 0xc2, 0xfb, 0x50, 0xf0, 0x21, 0x82, 0x7c, 0x53, 0x96,
	0x52, 0x02, 0x4b, 0x12, 0x28, 0xca, 0xbb, 0x19, 0x95, 0xa5, 0xd8, 0xf8, 0x27, 0xa6, 0xc1, 0xb9,
	0xf8, 0x99, 0xac, 0x6d, 0x2f, 0x59, 0x25, 0xb0, 0x92, 0x5e, 0xb4, 0xf2, 0x54, 0x2a, 0x74, 0xc2,
	0x84, 0xe2, 0x3c, 0x82, 0x12, 0xa6, 0x13, 0x8a, 0x82, 0xdf, 0x41, 0x51, 0x90, 0x45, 0x92, 0xcd,
	0x78, 0x1d, 0x17, 0xcc, 0x46, 0x16, 0xd3, 0xbf, 0xb1, 0x78, 0x07, 0x56, 0xda, 0x4d, 0xf1, 0x5b,
	0x4d, 0xda, 0xb2, 0x0d, 0xd0, 0x6e, 0x1e, 0x52, 0xcb, 0xb6, 0x1c, 0x63, 0x92, 0x50, 0x63, 0x3f,
	0x80, 0x0f, 0x4b, 0x0e, 0x70, 0xe8, 0xef, 0xba, 0x94, 0xf9, 0x98, 0xbf, 0x44, 0xc5, 0xd7, 0x90,
	0xef, 0x90, 0xb9, 0xc8, 0x74, 0xb5, 0xa2, 0x7f, 0x25, 0xfe, 0x2b, 0x28, 0x07, 0xf2, 0xcb, 0x4f,
	0x47, 0x74, 0x96, 0x09, 0xe3, 0xf0, 0x08, 0xd2, 0xad, 0xbe, 0xdf, 0xc9, 0xdd, 0xd9, 0x50, 0x3a,
	0xc6, 0xa0, 0xf6, 0x8d, 0x49, 0x72, 0xde, 0x2d, 0x58, 0x39, 0xa4, 0xc4, 0x36, 0xe8, 0xf5, 0xb8,
	0x52, 0x49, 0xcc, 0xcb, 0x7b, 0x1f, 0x65, 0x4d, 0xc7, 0x0e, 0x59, 0xca, 0x70, 0x9c, 0x8b, 0x36,
	0x84, 0x0b, 0x51, 0x96, 0x42, 0x70, 0x30, 0x7d, 0x5f, 0xe8, 0x39, 0x31, 0x2b, 0x99, 0x24, 0x77,
	0x75, 0xbe, 0xaf, 0x6d, 0x39, 0xd7, 0xdd, 0x6d, 0xc4, 0xa3, 0x45, 0xa2, 0xf8, 0x0d, 0x64, 0xdb,
	0xc4, 0xa0, 0xb3, 0xa5, 0x6c, 0x4a, 0x07, 0x49, 0xf5, 0x41, 0x6b, 0xb0, 0xc2, 0x05, 0xc9, 0x90,
	0x27, 0xc8, 0xe3, 0x3a, 0xe4, 0xc3, 0xf6, 0x0d, 0x7a, 0x34, 0x69, 0x17, 0x9c, 0x05, 0xb5, 0x69,
	0x9e, 0x34, 0xbe, 0xaa, 0xb0, 0xde, 0x3b, 0x30, 0x66, 0xc3, 0x96, 0x35, 0x73, 0xba, 0x64, 0x34,
	0x76, 0x18, 0xa1, 0xe8, 0xae, 0xbc, 0x6c, 0xe2, 0xad, 0xaf, 0x05, 0xdd, 0x1b, 0xde, 0x31, 0x38,
	0x73, 0xf6, 0xb9, 0xa2, 0xa0, 0x1a, 0x64, 0xf9, 0xb8, 0xa2, 0xb2, 0x04, 0x88, 0xbb, 0x43, 0x5b,
	0xbc, 0x57, 0x04, 0xfe, 0x21, 0x14, 0xc4, 0x78, 0x93, 0x53, 0x76, 0x95, 0xd3, 0xd1, 0xd0, 0x95,
	0xcf, 0x38, 0xeb, 0x3e, 0xe4, 0x7a, 0x84, 0xf9, 0xf7, 0x6a, 0x40, 0x11, 0x57, 0x65, 0x48, 0x89,
	0xdd, 0x9c, 0x11, 0x45, 0x0c, 0x35, 0x5a, 0x97, 0x98, 0x68, 0xc6, 0xb5, 0xd5, 0x70, 0x29, 0x4e,
	0xd9, 0x85, 0x7c, 0x8f, 0x30, 0x31, 0x3c, 0x6b, 0x91, 0x30, 0x5f, 0xd0, 0xfe, 0xbb, 0xb6, 0x10,
	0x27, 0x36, 0x00, 0xf6, 0x09, 0x0b, 0xba, 0x31, 0x10, 0x97, 0x3d, 0xac, 0x45, 0xdf, 0xfc, 0xbf,
	0xe4, 0xec, 0x40, 0xae, 0x69, 0x9a, 0xc4, 0x66, 0x31, 0x3c, 0xef, 0x2a, 0x2d, 0x98, 0x62, 0x7e,
	0xc6, 0x12, 0xbd, 0x05, 0xea, 0x8b, 0xf9, 0x30, 0x74, 0x15, 0x06, 0x01, 0xb9, 0xd0, 0x34, 0x4f,
	0x70, 0x6a, 0x6f, 0xe7, 0xfc, 0x52, 0x4f, 0x7d, 0xbb, 0xd4, 0x53, 0x17, 0x97, 0xba, 0x72, 0xe6,
	0xe9, 0xca, 0x27, 0x4f, 0x57, 0xbe, 0x78, 0xba, 0x72, 0xee, 0xe9, 0xca, 0x85, 0xa7, 0x2b, 0x3f,
	0x3c, 0x3d, 0xf5, 0xd3, 0xd3, 0x95, 0x8f, 0xdf, 0xf5, 0xd4, 0x20, 0xc7, 0xa9, 0x0f, 0x7e, 0x05,
	0x00, 0x00, 0xff, 0xff, 0xfc, 0x14, 0xf7, 0x0f, 0xf3, 0x07, 0x00, 0x00,
}
